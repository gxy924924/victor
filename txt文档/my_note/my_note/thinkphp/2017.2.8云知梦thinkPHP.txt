2017/2/8==>上次复习
1.tp安装
2.MVC的开发模式

今天：
1.C控制器
2.M模型
3.V视图
4.V模板引擎
5.调试
6.缓存
7.杂项

==》调试模式
错误报错设置：
D:\web\thinkphp\ThinkPHP3.2.2\ThinkPHP\Tpl\think_exception.tpl
注如果在index.php中将调试模式关闭，则tp不再报错。

-》定制错误页面
可在convention.php中、或自定义config.php中修改默认错误跳转页：
    'TMPL_EXCEPTION_FILE'   =>  THINK_PATH.'Tpl/think_exception.tpl',// 异常页面的模板文件

异常模板中可以使用的异常变量有：

$e['file']异常文件名
$e['line'] 异常发生的文件行数
$e['message'] 异常信息
$e['trace'] 异常的详细Trace信息

-》在操作中获取当前地址中模块和操作：
1.$_GET['_URL_'][0];
  $_GET['_URL_'][1];
  【未获取到】
2.MODULE_NAME;
  ACTION_NAME;

常量：
MODULE_NAME;模块名
ACTION_NAME;方法名
IS_GET
IS_POST
IS_AJAX
__ROOT__ 网站根目录地址  
__APP__ 当前应用（入口文件）地址  
__MODULE__ 当前分组的URL地址  
__CONTROLLER__ 当前模块的URL地址  
__ACTION__ 当前操作的URL地址  
__SELF__ 当前URL地址  
__INFO__ 当前的PATH_INFO字符串  
__EXT__ 当前URL地址的扩展名  

-》空操作：当调用不存在的方法时会触发
function _empty(){
		echo "您操作的方法不存在！";
	}
可以在里边调用一个别的方法http://tp/ThinkPHP3.2.2/index.php/Index/Test/aa
	function _empty(){
		$this->myerror();
	}
	function myerror(){
		$this->display('myerror');
	}

-》空模块：当模块不存在时调用http://tp/ThinkPHP3.2.2/index.php/Index/aa
class EmptyController extends Controller {
	function index(){
		echo "空模块";
	}
}

->URL伪静态：在url中看不到php文件名，看到的是我们“伪装”的相应的文件名
	可以通过设置URL_HTML_SUFFIX参数随意在URL的最后增加你想要的静态后缀

->URL重写:REWRITE模式：
	路径模式第三种：'URL_MODEL'  =>  1,

->URL生成：U函数生成的路径
	U("index");  //U('地址表达式',['参数'],['伪静态后缀'],['显示域名'])

->URL大小写
'URL_CASE_INSENSITIVE' =>true   //不区分URL大小写

->URL重定向（只能在tp内部跳转）
$this->redirect('New/category', array('cate_id' => 2), 5, '页面跳转中...');

->页面跳转
$this->success();
$this->error();

// 操作完成3秒后跳转到 /Article/index
$this->success('操作完成','/Article/index',3);

->URL路由
当访问路由下的路径，会自动跳转到相应的路由目标路径，在config.php中定义
如访问：http://tp/ThinkPHP3.2.2/index.php/Index/news/1
// 开启路由
	'URL_ROUTER_ON'   => true, 
	'URL_ROUTE_RULES'=>array(
	'news/:id'          => 'Index/index',),

==>A方法-跨模块调用
	$test=A("Test");//跨模块-Test模块
	$test->test();//调用
	A('Admin://User')//跨项目-Admin项目下User模块
	A('Admin/User')//跨分组
	A('Admin://Tool/User')

==>R方法-调用模块中方法
	R('Test/test');//Test下的test方法

==>函数过滤（转化实体） 见：输入方法-》新方法I
php中addslashes()同效果

修改Dbmysql.class.php
在escapeString()下加一句
if(get_magic_quotes_gpc()){
	return($strs);
}

注：aa"bb 1.addslashes 变成aa\"bb
	  2.htmlspecialchars变成aa\&quot;bb,
	  3.mysql_escape_string变成aa\\&quot;bb

tp提供了新方法

==》方法I-过滤
I('变量类型.变量名',['默认值'],['过滤方法'])


=》传递值类型
var_dump(IS_POST); //判断传递值类型

IS_GET 判断是否是GET方式提交 
IS_POST 判断是否是POST方式提交 
IS_PUT 判断是否是PUT方式提交 
IS_DELETE 判断是否是DELETE方式提交 
IS_AJAX 判断是否是AJAX提交 
REQUEST_METHOD 当前提交类型 

==>tp中使用ajax
注意：display中的东西也会返回给ajax，所以传值时一定要注意

==>ajax返回
$this->ajaxReturn(返回数据，数据类型)
ajaxReturn($data,$type='')

==>参数绑定（给URL的参数强制传参数，或自动赋予参数）
public function read($id=0){
echo $id;
}
绑定参数id=0 输出0
public function read($id){}
此时若不输入参数会报错

==>M方法：数据库查询
	相当于：$user=M('user');--->$user=new \Think\Model("User");
	function mysql(){
		$user=M('user');
		$rows=$user->select();
		//相当于$model=M(); $rows=$model->query('select * from user order by id');
		echo "<pre>";
		print_r($rows);
		echo "</pre>";
	}

==>D方法：使用自定义模型（在自定义模型不存在时相当于M方法）
	相当于$user=M('user');--->$user=new \Index\Model\UserModel();

-》get_class方法：可以知道一个方法的类
	echo get_class();
		//输出\Model\UserModel

->getLastSql();//查询模型最后一次查询数据库的查询语句
echo $user->getLastSql();
		//输出SELECT * FROM `user` WHERE `id` = 1 


-->更改自定义模型的查询表名
protected $tableName="user";

-->查找数据主键 getPk()   //primary key 主键通常是id
echo "</br>getPk==>".$user->getPk();

-->连接数据库：
ThinkPHP/conf/convention.php
app/Index/conf/config.php
并将数据库信息写入

-->$model->create();
//生成model对象中的数据对象data，它可以智能过滤post中与表中字段不相符的下标
//自动验证：在后台加一次自动的验证
//自动完成:通过model来处理数据，完成相应功能
//字段映射：将不同下标的值赋予数据库

--》写入数据库
方法1：使用create会智能一点
		$_POST['username']='user3';
		$_POST['password']='345';
		$_POST['submit']='提交';
		$user=M('user');
		$user->create();
		$user->regtime=time();
		$user->add();
方法2：不用create
		$_POST['username']='user3';
		$_POST['password']='345';
		$_POST['submit']='提交';
		$user=M('user');
		$user->regtime=time();
		$user->add($_POST);

说明：如果不是$_POST则应$user->create($data);这样才能将数据写入

--》字段映射：在表单中隐藏真正的数据表字段,而真正字段写在模型中
	class UserModel extends Model {
	//protected $tableName="user";
	protected $_map =array(
		'name'=>'username',		//映射
		'pass'=>'password',
	);

	function mysql_s(){
		$_POST['name']='user3';
		$_POST['pass']='345';
		$user=D("User");		//已写好UserModel.class.php字段映射
		$user->create();
		echo "<pre>";
		print_r($user);
		echo "</pre>";
	}

-->>自动完成:UserModel
	protected $_auto=array(
		array('password','md5','3','function'),
		array('regtime','time','3','function'),
	);

-->自动验证：后台验证功能
	protected $_validate=array(
		array('username','require','用户名不能为空'),
		array('password','require','密码不能为空'),
		array('fcode','require','验证码不能为空'),
		array('password','repassword','两次密码不相同',2,'confirm'),
		array('fcode','scode','两次验证码不相同',2,'confirm'),
	);
-->批量验证
	protected $patchValidate = true;	//系统支持数据的批量验证功能

	function mysql_s(){
		$_SESSION['scode']='abc';
		$_POST['name']='aa';
		$_POST['pass']='';
		$_POST['repassword']='aaa';
		$_POST['fcode']='vv';
		$_POST['email']='aaa@s.com';
		$user=D("User");		//已写好UserModel.class.php字段映射
		
		if($user->create()){
			echo "ok";
			$user->add();
		}else{
			echo "<pre>";
			print_r($user->getError());
			echo "</pre>";
		}
		

==》tp中CRUD操作
create select update delete

->insert:(add)				//增
1.$model->add($_POST);
2.$model->create();
  $model->add();

->update:(save)				//改
	function mysql_upd(){
		$_POST['username']='aaa';
		$_POST['password']='222';
		$_POST['id']='2';
		$user=M('user');
		$user->create();
		$user->save();
		echo "ok";
	}

->select:(select查找多行)		//查
->find:(find查一行)
	function mysql_sel(){
		$user=D('user');	//载入
		$rows=$user->select(); //查全部

		$rows=$user->where('id>2 and id<5')->select(); //条件查询
		
		$rows=$user->find(3);		//查一条
		 
		echo "<pre>";			//输出
		print_r($rows);
		echo "</pre>";
	}

->delete:(delete)			//删
	function mysql_del(){
		$id=5;
		$user=D('user');
		$user-> delete($id);
	}
	function mysql_del2(){
		$user=D('user');
		//$user->where('id=6')->delete();
		$user->where(array('id'=>'6'))->delete();
	}

--》连贯操作：连贯操作方法（也有些框架称之为链式操作）
	$User->where('status=1')->order('create_time')->limit(10)->select();
			//查询一个User表的满足状态为1的前10条记录，
			并希望按照用户的创建时间排序 

--》AR（ActiveRecords）模式：可以认为是数据对象模式。
	$User->id = 1;
	$User->name = 'TOPThink'; // 修改数据对象
	$User->save(); // 保存当前数据对象

===》连贯操作：方法细节：
-》DISTINCT：返回唯一不同的值；
	$Model->distinct(true)->field('name')->select();
		//返回所有name的值，并将重复的内容删掉

-》JOIN：连接（左连接，右连接。。）
	INNER JOIN: 如果表中有至少一个匹配，则返回行，等同于 JOIN 
	LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 
	RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 
	FULL JOIN: 只要其中一个表中存在匹配，就返回行 
左连接：数据库查询语句：
	select user.username,score.num from user left join score on user.username=score.uid;
		//查询user表的username和score表的num并将左边数据全部输出，右边数据匹配到
		则输出，未匹配到，输出NULL值
	select user.username,if(score.num,score.num,0) from user left join score on 
	user.username=score.uid;
		//在上面的基础上添加score.num如果为真返回score.num，为假则返回0
    -->tp中查询
	function mysql_lj(){
		$user=D('User');
		$sel=$user->field('username,score.num')->JOIN('left join score on user.username=score.uid')->select();
		echo $user->getLastSql();
		echo "<pre>";
		print_r($sel);
		echo "</pre>";
	}